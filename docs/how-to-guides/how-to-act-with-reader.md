# How to Use the Reader

## __Input Files__

The reader requires specific input files for its operation. These files are typically generated by the experiment instrument and include an ELN file with user-provided metadata or an ELN schema file to write your metadata via NOMAD. Below, we discuss the input files and how they are used in different situations.

The reader primarily requires three types of input files:

### __Raw Data File__

The raw data file is generated by the instrument's software. These files may contain measured data, instrument setup, and some metadata, but not all required information may be present. The metadata and instrument setup information required by the NeXus application definition can be supplied via the ELN file.

<!-- TODO: Add how raw path is formatted by parsers. -->
<!-- TODO: Mention on the home page that to use this package, users must have good knowledge of NeXus semantics and application definitions for SPM. -->

### __ELN Schema File__

A YAML schema file (with the extension `.scheme.archive.yaml`) contains the schema structure according to the NeXus application definition and some operational metadata for NOMAD. NOMAD reads this schema file and creates an archive file (with the extension `.archive.json`). Later, NOMAD renders a GUI representing the archive file, where users can fill in the metadata corresponding to the NeXus schema. NOMAD then generates a structured YAML file (another type of ELN file with the extension `.yaml`) that collects the user-provided data. The final ELN file (with the extension `.yaml`) is read by the reader, and the data is written to the NeXus file. For a visualization of this process, follow the `Drag and Drop Example in NOMAD` in [Use Reader in NOMAD](../tutorials/reader-use-in-nomad.md).

In the tabbed window below, an example ELN schema file for an STS experiment is shown. The schema is designed according to the NeXus application definition `NXsts`. The schema file contains all required metadata fields that are not supplied by the raw file but are required by the `NXsts` application definition. Tabs from left to right show the schema file, the generated archive file, the graphical representation of the archive file in NOMAD, and the final ELN file (with the extension `.yaml`).

=== "STS Schema for NOMAD (sts.scheme.archive.yaml)"
    <div class=scrollable>
    ```yaml
    definitions:
    name: An ELN example for STS (Scanning Tunneling Spectroscopy).
    sections:
        sts:
        base_sections:
            - pynxtools.nomad.dataconverter.NexusDataConverter # Converter module
            - nomad.datamodel.data.EntryData
        m_annotations:
            template:
            reader: spm
            nxdl: NXsts
            eln:
            hide: []
        # Schema according to the applicatoin definition NXsts
        quantities:
            default:
            type: str
            m_annotations:
                eln:
                component: StringEditQuantity
            description: |
                The name of the NXdata group that comes as child of the entry group for default plot visualization
                to be displayed upon the entry of NeXus file.
            definition:
            type:
                type_kind: Enum
                type_data:
                - NXsts
            m_annotations:
                eln:
                component: EnumEditQuantity
            description: |
                Name of the definitions from NeXus app def designed for STS experiments, one can use 
                NXsts or NXspm, but NXsts is recommended.
            experiment_technique:
            type:
                type_kind: Enum
                type_data:
                - STS
            m_annotations:
                eln:
                component: EnumEditQuantity
            description: |
                Name of the technique used for the experiment, e.g. STS.
            experiment_description:
            type: str
            m_annotations:
                eln:
                component: RichTextEditQuantity
            description: |
                Descriptive comments for this experiment, added by the experimenter in eln or 
                coming from the output file, e.g. Comment01 SYNC & Filter LP 8order WITHDRAW
                600 steps, locked Au(111), 50pA, 100 mV set point, 1mV DCA, 973Hz,138
                1st H, -84 2nd H.
            identifier_experiment: 
            type: str
            m_annotations:
                eln:
                component: StringEditQuantity
            description: |
                An unique identifier fot the experiment. e.g. the identifier
                could be specific for a lab or experiment team.
            identifier_collection: 
            type: str
            m_annotations:
                eln:
                component: StringEditQuantity
            description: |
                An unique identifier of a collection. Use this
                if the experiment if part of a collection of experiments
        sub_sections:
            User:
            section:
                m_annotations:
                eln:
                    overview: true
                quantities:
                name:
                    type: str
                    m_annotations:
                    eln:
                        component: StringEditQuantity
                    description: |
                    Name of the user who performed the experiment.
                affiliation:
                    type: str
                    shape: "*"
                    m_annotations:
                    eln:
                        component: StringEditQuantity
                    description: |
                    Affiliation of the user who performed the experiment.
                email:
                    type: str
                    shape: "*"
                    m_annotations:
                    eln:
                        component: StringEditQuantity
                    description: |
                    List of emails from users who performed the experiment.
            Instrument:
            section:
                m_annotations:
                eln:
                    overview: true
                sub_sections:
                hardware:
                    section:
                    m_annotations:
                        eln:
                        overview: true
                    quantities:
                        name:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            Name of the hardware. (e.g. Nanonis).
                        vendor:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            Name of the manufacturer of the hardware (e.g. Nanonis).
                        model:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            Version or model of the component named by the manufacturer (e.g. Generic 5e).
                        model/@version:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            If model has a distinquishable version (e.g. BP5e).
                software:
                    section:
                    m_annotations:
                        eln:
                        overview: true
                    quantities:
                        vendor:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            Name of the manufacturer of the software.
                        name:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            Name of the software. (e.g. Nanonis).
                        model:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            Version or model, required to choose correct file parser, of the component named 
                            by the manufacturer (e.g. Generic 5e).
                            Note that model should be exactly the same as the one in the experiment file.
                        model/@version:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            If model has a distinquishable version (e.g. BP5e).
                lockin_amplifier:
                    section:
                    m_annotations:
                        eln:
                        overview: true
                    quantities:
                        modulation_signal:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            Type of the signal either in voltage or current.
                        lockin_current_flip_sign:
                        type: np.float64
                        m_annotations:
                            eln:
                            component: NumberEditQuantity
                        description: |
                            The sign (1 or -1) that defines the sign of the lock-in current.
                            The calibration procedure with retracted tip is normally performed
                            to compensate for the signal phase delay in SPM. The procedure 
                            yields two possible solutions, this number should be equal to 1 or -1
                            depending on which solution is chosen (this concept mainly used in 
                            STS experiments, e.g. in Nanonis machine).
                scan_environment:
                    section:
                    m_annotations:
                        eln:
                        overview: true
                    quantities:
                        tip_temp:
                        type: np.float64
                        unit: kelvin
                        m_annotations:
                            eln:
                            component: NumberEditQuantity
                            defaultDisplayUnit: K
                        description: |
                            Temperature of STM head. Note: At least one field from tip_temp,
                            cryo_bottom_temp and cryo_shield_temp must be provided.
                            At least one field from tip_temp, cryo_bottom_temp and cryo_shield_temp must be provided.
                        cryo_bottom_temp:
                        type: np.float64
                        unit: kelvin
                        m_annotations:
                            eln:
                            component: NumberEditQuantity
                            defaultDisplayUnit: K
                        description: |
                            Temperature of the cold tail of the cryostat. Note: 
                            At least one field from tip_temp, cryo_bottom_temp and cryo_shield_temp must be provided.
                        cryo_shield_temp:
                        type: np.float64
                        unit: kelvin
                        m_annotations:
                            eln:
                            component: NumberEditQuantity
                            defaultDisplayUnit: K
                        description: |
                            Temperature of liquid nitrogen shield. Note: At
                            least one field from tip_temp, cryo_bottom_temp and cryo_shield_temp.
            Sample:
            section:
                m_annotations:
                eln: 
                    overview: true
                quantities:
                name:
                    type: str
                    m_annotations:
                    eln:
                        component: StringEditQuantity
                    description: |
                    Name of the sample.
                chemical_formula:
                    type: str
                    m_annotations:
                    eln:
                        component: StringEditQuantity
                    description: |
                    The chemical formula specified using CIF conventions.
                    Abbreviated version of CIF standard:
                    * Only recognized element symbols may be used.
                    * Each element symbol is followed by a 'count' number. A count of '1' may be omitted.
                    * A space or parenthesis must separate each cluster of (element symbol + count).
                    * Where a group of elements is enclosed in parentheses, the multiplier for the
                        group must follow the closing parentheses. That is, all element and group
                        multipliers are assumed to be printed as subscripted numbers.
                    * Unless the elements are ordered in a manner that corresponds to their chemical
                        structure, the order of the elements within any group or moiety depends on
                        whether or not carbon is present.
                    * If carbon is present, the order should be: 
                        - C, then H, then the other elements in alphabetical order of their symbol.
                        - If carbon is not present, the elements are listed purely in alphabetic order of their symbol.
                    * This is the *Hill* system used by Chemical Abstracts.
                description:
                    type: str
                    m_annotations:
                    eln:
                        component: RichTextEditQuantity
                    description: |
                    Description of the sample or sample preparation.
                sub_sections:
                Sample_component:
                    section:
                    m_annotations:
                        eln:
                        overview: true
                    description: |
                        A sample component is a part of the sample that is of interest.
                        For example, a sample component could be a layer of a multilayer sample.
                    quantities:
                        name:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            Name of the sample component.
                        sample_id:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            An unique identifier for the sample component.
                        chemical_formula:
                        type: str
                        m_annotations:
                            eln:
                            component: StringEditQuantity
                        description: |
                            The chemical formula specified using CIF conventions.
                            Abbreviated version of CIF standard:
                            * Only recognized element symbols may be used.
                            * Each element symbol is followed by a 'count' number. A count of '1' may be omitted.
                            * A space or parenthesis must separate each cluster of (element symbol + count).
                            * Where a group of elements is enclosed in parentheses, the multiplier for the
                            group must follow the closing parentheses. That is, all element and group
                            multipliers are assumed to be printed as subscripted numbers.
                            * Unless the elements are ordered in a manner that corresponds to their chemical
                            structure, the order of the elements within any group or moiety depends on
                            whether or not carbon is present.
                            * If carbon is present, the order should be:
                            - C, then H, then the other elements in alphabetical order of their symbol.
                            - If carbon is not present, the elements are listed purely in alphabetic order of their symbol.
                            * This is the *Hill* system used by Chemical Abstracts.
                        description:
                        type: str
                        m_annotations:
                            eln:
                            component: RichTextEditQuantity
                        description: |
                            Description of the sample component or sample preparation.
                History:
                    section:
                    m_annotations:
                        eln:
                        overview: true
                    quantities:
                        notes:
                        type: str
                        m_annotations:
                            eln:
                            component: RichTextEditQuantity
                        description: |
                            Notes about the sample history.
    ```
    </div>
=== "Archive File (sts.archive.json)"
    <div markdown="1" class=scrollable>
    ```json
    {
        "data": {
            "m_def": "../upload/raw/sts.scheme.archive.yaml#/definitions/section_definitions/0",
            "reader": "spm",
            "nxdl": "NXsts",
            "input_files": ["config.json", "Bias-Spectroscopy00015_20230420.dat"],
            "export": true,
            "default": "current_filter_grad",
            "definition": "NXsts",
            "experiment_technique": "STS",
            "experiment_description": "<p>The experiment with</p>\n<p>Bias: -50mA<br />Setpoint: 25pA</p>",
            "identifier_experiment": "Au_mica_2023_Y_A_diPAMY_154-211C_370C_1min_385C_30min_400C_1min_400C_30min_415_30min_430_30min_11min_30min_30min_20230416_20230420",
            "identifier_collection": "Au_mica_2023_Y_A_diPAMY_154-211C_370C_1min_385C_30min_400C_1min_400C_30min_415_30min_430_30min_11min_30min_30min_20230419",
            "User": {
            "name": "Yichen Jin",
            "affiliation": [
                "Rubel Mozumder",
                "Dr. Cojal Gonzalez",
                "Dr. Carlos-Andres Palma"
            ],
            "email": [
                "ycjin@physik.hu-berlin.de",
                "rubel.mozumder@physik.hu-berlin.de",
                "cojal@physik.hu-berlin.de",
                "palma@physik.hu-berlin.de"
            ]
            },
            "Instrument": {
            "hardware": {
                "name": "Nanonis",
                "vendor": "Nanonis",
                "model": "Generic5",
                "model/@version": "5"
            },
            "software": {
                "vendor": "Nanonis",
                "name": "Nanonis",
                "model": "Generic5",
                "model/@version": "5"
            },
            "lockin_amplifier": { "modulation_signal": "Current", "flip_sign": -1 },
            "Scan_environment": { "head_temperature": 10 }
            },
            "Sample": {
            "name": "diPAMY",
            "description": "<div>Substrate:</div>\n<div>Two layers stack: Au-Mica</div>",
            "Sample_component": {
                "name": "Au(Mica)",
                "identifier_component": "Au(KAl3Si3O12H2)",
                "description": "<div>Substrate:</div>\n<div>Two layers stack: Au-Mica</div>"
            }
            }
        }
    }
    ```
    </div>
=== "Graphical Representation of archive.json in NOMAD"
    <div class="scrollable-img">
        <img src="../assets/Archive_json_overview.png" alt="Example image">
    </div>
=== "Eln yaml file (generated by NOMAD)"
    <div class="scrollable">
    ```yaml
    Sample:
    name: diPAMY
    sample_component_set:
        sample_component:
        chemical_formula: Au(KAl3Si3O12H2)
        description: '<p>Substrate:</p>

            <p>Two layers stack: Au-Mica</p>'
        name: Au(Mica)
    default: current_filter_grad
    definition: NXsts
    experiment_description: '<p>The experiment with</p>
    <p>Bias: -50mA</p>
    <p>Setpoint: 25pA</p>'
    experiment_instrument:
    hardware:
        model: Generic5e
        model/@version: 5
        name: Nanonis
        vendor: Nanonis
    lockin_amplifier:
        lockin_current_flip_sign: -1.0
        modulation_signal: Current
    scan_environment:
        tip_temp:
        unit: K
        value: 10.0
    software:
        model: Generic5e
        model/@version: 5
        name: Nanonis
        vendor: Nanonis
    experiment_technique: STS
    identifier_collection: Au_mica_2023_Y_A_diPAMY_154-211C_370C_1min_385C_30min_400C_1min_400C_30min_415_30min_430_30min_11min_30min_30min_20230419_
    identifier_experiment: Au_mica_2023_Y_A_diPAMY_154-211C_370C_1min_385C_30min_400C_1min_400C_30min_415_30min_430_30min_11min_30min_30min_20230416_20230420
    user:
    affiliation:
        - Rubel Mozumder
        - Dr. Cojal González, José David
        - Dr. Carlos-Andres Palma
    email:
        - ycjin@physik.hu-berlin.de
        - rubel.mozumder@physik.hu-berlin.de
        - cojal@physik.hu-berlin.de
        - palma@physik.hu-berlin.de
        name: Yichen Jin
    ```
    </div>


### __ELN YAML File__

An ELN YAML file is similar to the YAML file (with the extension `.yaml`) generated by NOMAD from the ELN schema file (with the extension `.scheme.archive.yaml`). This ELN YAML file also contains the same structure as the application definition but is much simpler than the __ELN Schema File__. Such a file can be written by the user following the application definition `NXsts` without the help of NOMAD. This ELN file is only compatible for use with the reader invoked via the command-line interface (see [Transfer Raw Data](../reference/transfer-raw-data.md) guide).

=== "Eln yaml file (user provided)"
    <div class="scrollable">
    ```yaml
    Sample:
    name: diPAMY
    sample_component_set:
        sample_component:
        chemical_formula: Au(KAl3Si3O12H2)
        description: 'Substrate:
            Two layers stack: Au-Mica'
        name: Au(Mica)
    default: current_filter_grad
    definition: NXsts
    experiment_description: |
        'The experiment with
        Bias: -50mA
        Setpoint: 25pA'
    experiment_instrument:
    hardware:
        model: Generic5e
        model/@version: 5
        name: Nanonis
        vendor: Nanonis
    lockin_amplifier:
        lockin_current_flip_sign: -1.0
        modulation_signal: Current
    scan_environment:
        tip_temp:
        unit: K
        value: 10.0
    software:
        model: Generic5e
        model/@version: 5
        name: Nanonis
        vendor: Nanonis
    experiment_technique: STS
    identifier_collection: Au_mica_2023_Y_A_diPAMY_154-211C_370C_1min_385C_30min_400C_1min_400C_30min_415_30min_430_30min_11min_30min_30min_20230419_
    identifier_experiment: Au_mica_2023_Y_A_diPAMY_154-211C_370C_1min_385C_30min_400C_1min_400C_30min_415_30min_430_30min_11min_30min_30min_20230416_20230420
    user:
    affiliation:
        - Rubel Mozumder
        - Dr. Cojal González, José David
        - Dr. Carlos-Andres Palma
    email:
        - ycjin@physik.hu-berlin.de
        - rubel.mozumder@physik.hu-berlin.de
        - cojal@physik.hu-berlin.de
        - palma@physik.hu-berlin.de
    name: Yichen Jin
    ```
    </div>

### __Config File__

The config file carries mapping information from the raw data to the NeXus Application Definition concepts. The config file follows certain rules for how the raw data will be processed and organized in the NeXus file. It is expected that lab users scrutinize the config file and modify it according to their needs. The file does not need to be modified for the underlying data structure, only for raw data paths.

=== "Typical structure of config file (for nonanois STS data)"
    <div class="scrollable-img">
    ```json
    {
        "ENTRY[entry]": {
            "@default": { "raw_path": "@default:current_filter" },
            "definition": { "@version": "" },
            "start_time": {
            "raw_path": "/Start time/value"
            },
            "end_time": {
            "raw_path": "/Saved Date/value"
            },
            "INSTRUMENT[instrument]": {
            "lockin_amplifier": {
                "modulation_status": {
                "raw_path": "/Lock-in/Lock-in status/value"
                },
                "reference_frequency": {
                "raw_path": "/Lock-in/Frequency/value",
                "@units": "/Lock-in/Frequency/unit"
                },
                "modulation_signal": {
                "raw_path": "@default:Current"
                },
                "demodulated_signal": {
                "raw_path": "@default:Current"
                },
                "reference_amplitude": {
                "raw_path": "/Lock-in/Amplitude/value",
                "@units": "/Lock-in/Modulated signal/Bias/unit"
                },
                "demodulated_frequency": "",
                "demodulated_amplitude": "",
                "demodulator_channels": "",
                "recorded_channels": "",
                "active_channel": {
                "raw_path": ""
                },
                "flip_sign": "",
                "low_passN": [
                {
                    "d1": {
                    "raw_path": "/Lock-in/LP Filter Cutoff D1/value",
                    "@units": "/Lock-in/LP Filter Cutoff D1/unit"
                    }
                },
                {
                    "d2": {
                    "raw_path": "/Lock-in/LP Filter Cutoff D2/value",
                    "@units": "/Lock-in/LP Filter Cutoff D2/unit"
                    }
                }
                ],
                "lp_filter_orderN": [
                {
                    "d1": { "raw_path": "/Lock-in/LP Filter Order D1/value" },
                    "d2": { "raw_path": "/Lock-in/LP Filter Order D2/value" }
                }
                ],
                "high_passN": [
                {
                    "d1": {
                    "raw_path": "/Lock-in/HP Filter Cutoff D1/value",
                    "@units": "/Lock-in/HP Filter Cutoff D1/unit"
                    }
                },
                {
                    "d2": {
                    "raw_path": "/Lock-in/HP Filter Cutoff D2/value",
                    "@units": "/Lock-in/HP Filter Cutoff D2/unit"
                    }
                }
                ],
                "hp_filter_orderN": [
                { "d1": { "raw_path": "/Lock-in/HP Filter Order D1/value" } },
                { "d2": { "raw_path": "/Lock-in/HP Filter Order D2/value" } }
                ],
                "ref_offset_phaseN[ref_offset_phase_n]": [
                {
                    "d1": {
                    "raw_path": "/Lock-in/Reference phase D1/value",
                    "@units": "/Lock-in/Reference phase D1/unit"
                    }
                },
                {
                    "d2": {
                    "raw_path": "/Lock-in/Reference phase D2/value",
                    "@units": "/Lock-in/Reference phase D2/unit"
                    }
                }
                ],
                "harmonic_orderN[harmonic_order_n]": [
                { "d1": { "raw_path": "/Lock-in/Harmonic D1/value" } },
                { "d2": { "raw_path": "/Lock-in/Harmonic D2/value" } }
                ],
                "dc_offset_valueN": [
                {
                    "d1": {
                    "raw_path": "",
                    "@units": ""
                    }
                },
                {
                    "d2": {
                    "raw_path": "",
                    "@units": ""
                    }
                }
                ]
            },
            "real_time_controller": {
                "fabrication": {
                "model": {
                    "raw_path": "/NanonisMain/RT Release/value"
                }
                },
                "frequency": {
                "raw_path": "/NanonisMain/RT Frequency/value",
                "@units": "/NanonisMain/RT Frequency/unit"
                },
                "acquisition_time": {
                "raw_path": "/NanonisMain/Acquisition Period/value",
                "@units": "/NanonisMain/Acquisition Period/unit"
                },
                "animation_time": {
                "raw_path": "/NanonisMain/Animations Period/value",
                "@units": "/NanonisMain/Animations Period/unit"
                },
                "measurement_time": {
                "raw_path": "/NanonisMain/Measurements Period/value",
                "@units": "/NanonisMain/Measurements Period/unit"
                },
                "indication_time": {
                "raw_path": "/NanonisMain/Indicators Period/value",
                "@units": "/NanonisMain/Indicators Period/unit"
                }
            },
            "bias_spectroscopy_environment": {
                "SPM_BIAS_SPECTROSCOPY[bias_spectroscopy]": {
                "measurement_type": "",
                "SPM_POSITIONER[spm_positioner]": {
                    "z_controller": {
                    "feedback_on": {
                        "raw_path": "/Z-Controller/Controller status/value"
                    },
                    "set_point": {
                        "raw_path": "/Z-Controller/Setpoint/value",
                        "@units": "/Z-Controller/Setpoint unit/value"
                    },
                    "tip_lift": {
                        "raw_path": "/Z-Controller/TipLift/value",
                        "@units": "/Z-Controller/TipLift/unit"
                    },
                    "z": {
                        "raw_path": "/Z-Controller/Z/value",
                        "@units": "/Z-Controller/Z/unit"
                    },
                    "K_i": {
                        "raw_path": "/Z-Controller/I gain/value"
                    },
                    "K_p": {
                        "raw_path": "/Z-Controller/P gain/value"
                    },
                    "D_t": {
                        "raw_path": "/Z-Controller/Time const/value",
                        "@units": "/Z-Controller/Time const/unit"
                    },
                    "controller_label": {
                        "raw_path": "/Z-Controller/Controller name/value"
                    },
                    "z_offset_value": {
                        "raw_path": "/Bias Spectroscopy/Z offset/value",
                        "@units": "/Bias Spectroscopy/Z offset/unit"
                    }
                    }
                },
                "BIAS_SWEEP[bias_sweep]": {
                    "#note": "This group will be handled in _construct_bias_sweep_grp.",
                    "scan_type": "",
                    "settling_time": {
                    "raw_path": "/Bias Spectroscopy/Settling time/value",
                    "@units": "/Bias Spectroscopy/Settling time/unit"
                    },
                    "first_settling_time": {
                    "raw_path": "/Bias Spectroscopy/1st Settling time/value",
                    "@units": "/Bias Spectroscopy/1st Settling time/unit"
                    },
                    "end_settling_time": {
                    "raw_path": "/Bias Spectroscopy/End Settling time/value",
                    "@units": "/Bias Spectroscopy/End Settling time/unit"
                    },
                    "max_slew_rate": {
                    "raw_path": "/Bias Spectroscopy/Max Slew rate/value",
                    "@units": "/Bias Spectroscopy/Max Slew rate/unit"
                    },
                    "final_z": "",
                    "total_spectroscopy_time": "",
                    "number_of_sweeps": {
                    "raw_path": "/Bias Spectroscopy/Number of sweeps/value"
                    },
                    "scan_region": {
                    "scan_range_bias": "",
                    "scan_offset_bias": {
                        "raw_path": ["/Bias/Offset/value"],
                        "@units": "/Bias/Offset/unit"
                    },
                    "scan_angleN[scan_angle_n]": "",
                    "scan_start_bias": {
                        "raw_path": "/Bias Spectroscopy/Sweep Start/value",
                        "@units": "/Bias Spectroscopy/Sweep Start/unit"
                    },
                    "scan_end_bias": {
                        "raw_path": "/Bias Spectroscopy/Sweep End/value",
                        "@units": "/Bias Spectroscopy/Sweep End/unit"
                    }
                    },
                    "linear_sweep": {
                    "scan_speed": "",
                    "scan_time": "",
                    "forward_speedN[forward_speed]": {
                        "raw_path": "/Scan/speed forw./value",
                        "@units": "/Scan/speed forw./unit"
                    },
                    "backward_speedN[backward_speed]": {
                        "raw_path": "/Scan/speed backw./value",
                        "@units": "/Scan/speed backw./unit"
                    },
                    "scan_points_bias": {
                        "raw_path": "/Bias Spectroscopy/Num Pixel/value"
                    },
                    "step_size_bias": "",
                    "reset_bias": "",
                    "backward_sweep": "",
                    "DATA[scan_data]": [
                        {
                        "data": {
                            "name": "current",
                            "raw_path": "/dat_mat_components/LI Demod 1 X/value",
                            "@units": "/dat_mat_components/LI Demod 1 X/unit",
                            "@long_name": "Lockin Demod 1X"
                        },
                        "0": {
                            "name": "voltage",
                            "raw_path": [
                            "/dat_mat_components/Bias calc/value",
                            "/dat_mat_components/Bias/value"
                            ],
                            "@units": [
                            "/dat_mat_components/Bias calc/unit",
                            "/dat_mat_components/Bias/unit"
                            ],
                            "@long_name": "Bias Voltage"
                        },
                        "title": { "raw_path": "@default:Lockin Signal 1X" },
                        "grp_name": "Lockin Demod 1X"
                        },
                        {
                        "data": {
                            "name": "Lockin Demod 1Y",
                            "raw_path": "/dat_mat_components/LI Demod 1 Y/value",
                            "@units": "/dat_mat_components/LI Demod 1 Y/unit"
                        },
                        "0": {
                            "name": "Bias Voltage",
                            "raw_path": [
                            "/dat_mat_components/Bias calc/value",
                            "/dat_mat_components/Bias/value"
                            ],
                            "@units": [
                            "/dat_mat_components/Bias calc/unit",
                            "/dat_mat_components/Bias/unit"
                            ]
                        },
                        "title": { "raw_path": "@default:Lockin Signal 1Y" },
                        "grp_name": "Lockin Demod 1Y"
                        },
                        {
                        "data": {
                            "name": "Lockin Demod 2X",
                            "raw_path": "/dat_mat_components/LI Demod 2 X/value",
                            "@units": "/dat_mat_components/LI Demod 2 X/unit"
                        },
                        "0": {
                            "name": "Bias Voltage",
                            "raw_path": [
                            "/dat_mat_components/Bias calc/value",
                            "/dat_mat_components/Bias/value"
                            ],
                            "@units": [
                            "/dat_mat_components/Bias calc/unit",
                            "/dat_mat_components/Bias/unit"
                            ]
                        },
                        "title": { "raw_path": "@default:Lockin Signal 2X" },
                        "grp_name": "Lockin Demod 2X"
                        },
                        {
                        "data": {
                            "name": "Lockin Demod 2Y",
                            "raw_path": "/dat_mat_components/LI Demod 2 Y/value",
                            "@units": "/dat_mat_components/LI Demod 2 Y/unit"
                        },
                        "0": {
                            "name": "Bias Voltage",
                            "raw_path": [
                            "/dat_mat_components/Bias calc/value",
                            "/dat_mat_components/Bias/value"
                            ],
                            "@units": [
                            "/dat_mat_components/Bias calc/unit",
                            "/dat_mat_components/Bias/unit"
                            ]
                        },
                        "title": { "raw_path": "@default:Lockin Signal 2Y" },
                        "grp_name": "Lockin Demod 2Y"
                        },
                        {
                        "data": {
                            "name": "Lockin Demod 1X_filter",
                            "raw_path": "/dat_mat_components/LI Demod 1 X [filt]/value",
                            "@units": "/dat_mat_components/LI Demod 1 X [filt]/unit"
                        },
                        "0": {
                            "name": "Bias Voltage",
                            "raw_path": [
                            "/dat_mat_components/Bias [filt]/value",
                            "/dat_mat_components/Bias calc/value",
                            "/dat_mat_components/Bias/value"
                            ],
                            "@units": [
                            "/dat_mat_components/Bias calc/unit",
                            "/dat_mat_components/Bias/unit"
                            ]
                        },
                        "title": { "raw_path": "@default:Lockin Demod 1X(filter)" },
                        "grp_name": "Lockin_Demod_1X_filter"
                        },
                        {
                        "data": {
                            "name": "Lockin Demod 1Y_filter",
                            "raw_path": "/dat_mat_components/LI Demod 1 Y [filt]/value",
                            "@units": "/dat_mat_components/LI Demod 1 Y [filt]/unit"
                        },
                        "0": {
                            "name": "Bias Voltage",
                            "raw_path": [
                            "/dat_mat_components/Bias [filt]/value",
                            "/dat_mat_components/Bias calc/value",
                            "/dat_mat_components/Bias/value"
                            ],
                            "@units": [
                            "/dat_mat_components/Bias calc/unit",
                            "/dat_mat_components/Bias/unit"
                            ]
                        },
                        "title": { "raw_path": "@default:Lockin Demod 1Y(filter)" },
                        "grp_name": "Lockin_Demod_1Y_filter"
                        },
                        {
                        "data": {
                            "name": "Lockin Demod 2X_filter",
                            "raw_path": "/dat_mat_components/LI Demod 2 X [filt]/value",
                            "@units": "/dat_mat_components/LI Demod 2 X [filt]/unit"
                        },
                        "0": {
                            "name": "Bias Voltage",
                            "raw_path": [
                            "/dat_mat_components/Bias [filt]/value",
                            "/dat_mat_components/Bias calc/value",
                            "/dat_mat_components/Bias/value"
                            ],
                            "@units": [
                            "/dat_mat_components/Bias calc/unit",
                            "/dat_mat_components/Bias/unit"
                            ]
                        },
                        "title": { "raw_path": "@default:Lockin Demod 2X(filter)" },
                        "grp_name": "Lockin_Demod_2X_filter"
                        },
                        {
                        "data": {
                            "name": "Lockin Demod 2Y_filter",
                            "raw_path": "/dat_mat_components/LI Demod 2 Y [filt]/value",
                            "@units": "/dat_mat_components/LI Demod 2 Y [filt]/unit"
                        },
                        "0": {
                            "name": "Bias Voltage",
                            "raw_path": [
                            "/dat_mat_components/Bias [filt]/value",
                            "/dat_mat_components/Bias calc/value",
                            "/dat_mat_components/Bias/value"
                            ],
                            "@units": [
                            "/dat_mat_components/Bias calc/unit",
                            "/dat_mat_components/Bias/unit"
                            ]
                        },
                        "title": { "raw_path": "@default:Lockin Demod 2Y(filter)" },
                        "grp_name": "Lockin_Demod_2Y_filter"
                        }
                    ]
                    }
                },
                "CIRCUIT[circuit]": ""
                },
                "independent_controllers": "",
                "measurement_sensors": ""
            },
            "current_sensorTAG[current_sensor]": {
                "current": {
                "raw_path": "/Current/Current/value",
                "@units": "/Current/Current/unit"
                },
                "calibration": {
                "calibration_parameters": {
                    "coefficient": {
                    "raw_path": "/Current/Calibration/value",
                    "@units": "/Current/Calibration/unit"
                    }
                }
                },
                "offset_value": {
                "raw_path": "/Current/Offset/value",
                "@units": "/Current/Offset/unit"
                },
                "AMPLIFIER[amplifier]": {
                "current_gain": { "raw_path": "" }
                }
            },
            "piezo_sensor": {
                "piezo_configuration": {
                "calibration": {
                    "calibration_type": {
                    "raw_path": "@default:active"
                    },
                    "calibration_date": {
                    "raw_path": ""
                    },
                    "rangeN[range_n]": { "x": "", "y": "", "z": "" },
                    "calibration_parameters": {
                    "coefficientN[coefficient_n]": [
                        {
                        "x": {
                            "raw_path": "/Piezo Configuration/Calib. X/value",
                            "@units": "/Piezo Configuration/Calib. X/unit"
                        }
                        },
                        {
                        "y": {
                            "raw_path": "/Piezo Configuration/Calib. Y/value",
                            "@units": "/Piezo Configuration/Calib. Y/unit"
                        }
                        },
                        {
                        "z": {
                            "raw_path": "/Piezo Configuration/Calib. Z/value",
                            "@units": "/Piezo Configuration/Calib. Z/unit"
                        }
                        }
                    ],
                    "second_order_correctionN[second_order_correction_n]": [
                        {
                        "x": {
                            "raw_path": "/Piezo Configuration/2nd order corr X/value",
                            "@units": "/Piezo Configuration/2nd order corr X/unit"
                        }
                        },
                        {
                        "y": {
                            "raw_path": "/Piezo Configuration/2nd order corr Y/value",
                            "@units": "/Piezo Configuration/2nd order corr Y/unit"
                        }
                        }
                    ]
                    },
                    "driftN[drift_n]": [
                    {
                        "x": {
                        "raw_path": "/Piezo Configuration/Drift X/value",
                        "@units": "/Piezo Configuration/Drift X/unit"
                        }
                    },
                    {
                        "y": {
                        "raw_path": "/Piezo Configuration/Drift Y/value",
                        "@units": "/Piezo Configuration/Drift Y/unit"
                        }
                    },
                    {
                        "z": {
                        "raw_path": "/Piezo Configuration/Drift Z/value",
                        "@units": "/Piezo Configuration/Drift Z/unit"
                        }
                    }
                    ],
                    "hv_gainN[hv_gain_n]": [
                    { "x": { "raw_path": "/Piezo Configuration/HV Gain X/value" } },
                    { "y": { "raw_path": "/Piezo Configuration/HV Gain Y/value" } },
                    { "z": { "raw_path": "/Piezo Configuration/HV Gain Z/value" } }
                    ],
                    "tiltN[tilt_n]": [
                    {
                        "x": {
                        "raw_path": "/Piezo Configuration/Tilt X/value",
                        "@units": "/Piezo Configuration/Tilt X/unit"
                        }
                    },
                    {
                        "y": {
                        "raw_path": "/Piezo Configuration/Tilt Y/value",
                        "@units": "/Piezo Configuration/Tilt Y/unit"
                        }
                    },
                    {
                        "z": {
                        "raw_path": "/Piezo Configuration/Tilt Z/value",
                        "@units": "/Piezo Configuration/Tilt Z/unit"
                        }
                    }
                    ],
                    "drift_correction_status": {
                    "raw_path": [
                        "/Piezo Configuration/Drift correction status/value",
                        "/Piezo Calibration/Drift correction status/value"
                    ]
                    }
                },
                "piezo_material": {
                    "curvature_radiusN": [
                    {
                        "x": {
                        "raw_path": "/Piezo Configuration/Curvature radius X/value",
                        "@units": "/Piezo Configuration/Curvature radius X/unit"
                        }
                    },
                    {
                        "y": {
                        "raw_path": "/Piezo Configuration/Curvature radius Y/value",
                        "@units": "/Piezo Configuration/Curvature radius Y/unit"
                        }
                    },
                    {
                        "z": {
                        "raw_path": "/Piezo Configuration/Curvature radius Z/value",
                        "@units": "/Piezo Configuration/Curvature radius Z/unit"
                        }
                    }
                    ]
                }
                },
                "SPM_POSITIONER[spm_positioner]": "",
                "x": { "raw_path": "/X/value", "@units": "/X/unit" },
                "y": { "raw_path": "/Y/value", "@units": "/Y/unit" },
                "z": { "raw_path": "/Z/value", "@units": "/Z/unit" },
                "AXISoffset_value[x_offset_value]": {
                "x": "",
                "y": "",
                "z": ""
                }
            },
            "sample_bias_voltage": {
                "bias_voltage": {
                "raw_path": "/Bias/Bias/value",
                "@units": "/Bias/Bias/unit"
                },
                "calibration": {
                "calibration_parameters": {
                    "coefficient": {
                    "raw_path": "/Bias/Calibration/value",
                    "@units": "/Bias/Calibration/unit"
                    }
                }
                }
            },
            "SCAN_ENVIRONMENT[scan_environment]": {
                "identifier_environment": {
                "raw_path": "/Scan/series name/value"
                },
                "cryo_bottom_temperature": { "@units": "" },
                "cryo_shield_temperature": { "@units": "" },
                "head_temperature": {
                "raw_path": "/Temperature 1/Temperature 1/value",
                "@units": "/Temperature 1/Temperature 1/unit"
                },
                "cryo_shield_temperature_sensor": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/cryo_shield_temperature_sensor",
                "cryo_bottom_temperature_sensor": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/cryo_bottom_temperature_sensor",
                "head_temperature_sensor": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/head_temperature_sensor"
            },
            "cryo_shield_temperature_sensor": {
                "temp_offset_value": "",
                "TEMPERATUREchannel[temperature_channel]": "",
                "calibration": {
                "calibration_parameters": {
                    "coefficient": ""
                }
                },
                "temperature_calibration": { "coefficients": "" },
                "DATA[data]": ""
            },
            "cryo_bottom_temperature_sensor": {
                "temp_offset_value": "",
                "TEMPERATUREchannel[temperature_channel]": "",
                "calibration": {
                "calibration_parameters": {
                    "coefficient": ""
                }
                },
                "temperature_calibration": { "coefficients": "" },
                "DATA[data]": ""
            },
            "sample_temperature_sensor": {
                "temp_offset_value": "",
                "TEMPERATUREchannel[temperature_channel]": "",
                "calibration": {
                "calibration_parameters": {
                    "coefficient": ""
                }
                },
                "temperature_calibration": { "coefficients": "" },
                "DATA[data]": ""
            },
            "head_temperature_sensor": {
                "temp_offset_value": "",
                "TEMPERATUREchannel[temperature_channel]": "",
                "calibration": {
                "calibration_parameters": {
                    "coefficient": ""
                }
                },
                "temperature_calibration": { "coefficients": "" },
                "DATA[data]": [
                {
                    "data": {
                    "name": "temperature1",
                    "raw_path": "/dat_mat_components/Temperature 1/value",
                    "@units": "/dat_mat_components/Temperature 1/unit"
                    },
                    "0": {
                    "name": "Bias Voltage",
                    "raw_path": [
                        "/dat_mat_components/Bias calc/value",
                        "/dat_mat_components/Bias/value"
                    ],
                    "@units": [
                        "/dat_mat_components/Bias calc/unit",
                        "/dat_mat_components/Bias/unit"
                    ],
                    "axis_ind": 0
                    },
                    "title": { "raw_path": "@default:Bias Spectroscopy Temperature1" },
                    "grp_name": "temperature1"
                },
                {
                    "data": {
                    "name": "temperature1_filter",
                    "raw_path": "/dat_mat_components/Temperature 1 [filt]/value",
                    "@units": "/dat_mat_components/Temperature 1 [filt]/unit"
                    },
                    "0": {
                    "name": "Bias Voltage",
                    "raw_path": [
                        "/dat_mat_components/Bias calc/value",
                        "/dat_mat_components/Bias/value"
                    ],
                    "@units": [
                        "/dat_mat_components/Bias calc/unit",
                        "/dat_mat_components/Bias/unit"
                    ],
                    "axis_ind": 0
                    },
                    "title": {
                    "raw_path": "@default:Bias Spectroscopy Temperature1(filter)"
                    },
                    "grp_name": "temperature1_filter"
                }
                ]
            }
            },
            "DATA[data]": [
            {
                "data": {
                "name": "Current",
                "raw_path": "/dat_mat_components/Current/value",
                "@units": "/dat_mat_components/Current/unit"
                },
                "0": {
                "name": "Bias Voltage",
                "raw_path": [
                    "/dat_mat_components/Bias calc/value",
                    "/dat_mat_components/Bias/value"
                ],
                "@units": [
                    "/dat_mat_components/Bias calc/unit",
                    "/dat_mat_components/Bias/unit"
                ]
                },
                "title": { "raw_path": "@default:Bias Spectroscopy" },
                "grp_name": "current"
            },
            {
                "data": {
                "name": "Current_filter",
                "raw_path": "/dat_mat_components/Current [filt]/value",
                "@units": "/dat_mat_components/Current [filt]/unit"
                },
                "0": {
                "name": "Bias Voltage",
                "raw_path": [
                    "/dat_mat_components/Bias [filt]/value",
                    "/dat_mat_components/Bias calc/value",
                    "/dat_mat_components/Bias/value"
                ],
                "@units": [
                    "/dat_mat_components/Bias calc/unit",
                    "/dat_mat_components/Bias/unit"
                ],
                "axis_ind": 0
                },
                "title": { "raw_path": "@default:Bias Spectroscopy(filter)" },
                "grp_name": "Current_filter"
            },
            {
                "data": {
                "name": "Current_filter",
                "raw_path": "/dat_mat_components/Current [filt]/value",
                "@units": "/dat_mat_components/Current [filt]/unit"
                },
                "0": {
                "name": "Bias Voltage",
                "raw_path": [
                    "/dat_mat_components/Bias [filt]/value",
                    "/dat_mat_components/Bias calc/value",
                    "/dat_mat_components/Bias/value"
                ],
                "@units": [
                    "/dat_mat_components/Bias calc/unit",
                    "/dat_mat_components/Bias/unit"
                ]
                },
                "title": { "raw_path": "@default:Bias Spectroscopy(filter)" },
                "grp_name": "Current_filter"
            },
            {
                "data": {
                "name": "Current_backward",
                "raw_path": "/dat_mat_components/Current [bwd]/value",
                "@units": "/dat_mat_components/Current [bwd]/unit"
                },
                "0": {
                "name": "Bias Voltage",
                "raw_path": [
                    "/dat_mat_components/Bias [filt]/value",
                    "/dat_mat_components/Bias calc/value",
                    "/dat_mat_components/Bias/value"
                ],
                "@units": [
                    "/dat_mat_components/Bias calc/unit",
                    "/dat_mat_components/Bias/unit"
                ]
                },
                "title": { "raw_path": "@default:Bias Spectroscopy(Backward)" },
                "grp_name": "Current_Backward"
            }
            ],
            "reproducibility_indicators": {
            "current": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/current_sensor/current",
            "current_gain": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/current_sensor/AMPLIFIER[amplifier]/current_gain",
            "current_offset": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/current_sensor/current_offset",
            "bias_sweep": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/bias_spectroscopy_environment/BIAS_SPECTROSCOPY[bias_spectroscopy]/BIAS_SWEEP[bias_sweep]",
            "reference_frequency": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/lockin_amplifier/reference_frequency",
            "modulation_signal": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/lockin_amplifier/modulation_signal"
            },
            "resolution_indicators": {
            "head_temperature": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/scan_environment/head_temperature",
            "cryo_bottom_temperature": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/scan_environment/cryo_bottom_temperature",
            "cryo_shield_temperature": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/scan_environment/cryo_shield_temperature",
            "bias_sweep": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/bias_spectroscopy_environment/BIAS_SPECTROSCOPY[bias_spectroscopy]/BIAS_SWEEP[bias_sweep]",
            "reference_frequency": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/lockin_amplifier/reference_frequency",
            "modulation_signal": "@default_link:/ENTRY[entry]/INSTRUMENT[instrument]/lockin_amplifier/modulation_signal"
            }
        }
    }
    ```
    </div>

#### __Modification Rules for `config.json` File__

__1.__ The simplest way to map NeXus concepts (fields and/or attributes) to the raw data file is to use a map from the concept name to another map object.
=== "Map for NeXus concept `field`"
    <p>The field <b>reference_frequency</b> of <b>lockin_amplifier</b> group is mapped to an object containnig "raw_path" and attributes e.g., "units", "demo_attr".
    The "raw_path" refers to the path of raw data (e.g., <it>/Lock-in/Frequency/value</it>).</p>
    <div class="scrollable">
    ```json
    "lockin_amplifier": {
        "reference_frequency": {
        "raw_path": "/Lock-in/Frequency/value",
        "@units": "/Lock-in/Frequency/unit",
        "@demo_attr": "/path/to/demo/value"
        },
    }
    ```
    </div>
=== "Map for NeXus concept `attribute`"
    <p>The attribute <b>default</b> of <b>entry</b> group is mapped to an object containing "raw_path".
    The "raw_path" refers to a path of raw data (e.g., <it>/NanonisMain/Experiment name/value</it>).
    <div class="scrollable">
    ```json
    "ENTRY[entry]": {
        "@default": { "raw_path": "/NanonisMain/Experiment name/value" },
    }
    ```
    </div>
__2.__ Set default values for a concept (field and/or attribute) via the config file
=== "Default Values for NeXus `field`"
    <p>A default value to a NeXus field <b>modulation_signal</b> field of <b>lockin_amplifier</b> can be set using the syntax "<b>@default:defatult_value</b>". 
    </p>
    <div class="scrollable">
    ```json
    "lockin_amplifier": {
        "modulation_signal": {
        "raw_path": "@default:current"
        },
    }
    ```
    </div>
=== "Deafault Values for NeXus `atttribute`"
    <p>A default value to a group attribute "<b>default</b>" of <b>entry</b> can be set by syntax "<b>@default:default_value</b>".</p>
    <div class="scrollable">
    ```json
    "ENTRY[entry]": {
        "@default": { "raw_path": "@default:current_grad" },
    }
    ```
    </div>

__3.__ Use the config file to define variadic names for concepts like groups, fields, and attributes. In NeXus concepts, a part or the entire concept name can be modified while instantiating objects, allowing multiple instances of the same concept to be created.

=== "Variable name for NeXus `group`"
    <p>Define variadic name for the group <b>TEMPERATURE[temperature]</b> of <b>INSTRUMENT</b> group using a map to one dimensional array of objects.
    Each element of the array is an object mapping from embedding part of name to the raw data path or nested concepts. The example array leads two instances of
    <b>TEMPERATURE[head_temperature_sensor]</b> and <b>TEMPERATURE[sample_temperature_sensor]</b>.
    </p>
    <div class="scrollable">
    ```json
    "INSTRUMENT[instrument]": {
        "TEMPERATURE[temperature]": [
            {"head_temperature_sensor":{ 
                "CHANNEL_temp[channel_temp]": {
                    "raw_path": "/Temperature 1/Temperature 1/value",
                    "@units": "/Temperature 1/Temperature 1/unit"
                    }
                }
            },
            {"sample_temperature_sensor": {
                "CHANNEL_temp[channel_temp]": {
                    "raw_path": "/Temperature 2/Temperature 2/value",
                    "@units": "/Temperature 2/Temperature 2/unit"
                    }
                }
            }
        ]
    }
    ```
    </div>
    <p> Or, simply write multiple groups like they are independent of each other.</p>
    <div class="scrollable">
    ```json
    "INSTRUMENT[instrument]": {
        "TEMPERATURE[head_temperature_sensor]": {
            "CHANNEL_temp[channel_temp]": {
                "raw_path": "/Temperature 1/Temperature 1/value",
                "@units": "/Temperature 1/Temperature 1/unit"
                }
            },
        "TEMPERATURE[sample_temperature_sensor]": {
            "CHANNEL_temp[channel_temp]": {
                "raw_path": "/Temperature 2/Temperature 2/value",
                "@units": "/Temperature 2/Temperature 2/unit"
                }
            },
    }
    ```
    </div>
=== "Variable name for NeXus `field`"
    <p>Define variadic name for the field <b>second_order_correction_N[second_order_correction_n]</b> of <b>piezo_configuration</b> group using one dimensional array of objects.
    Each element of array is an object mapping embedding part to the raw data path. The array leads a field <b>second_order_correction_N[second_order_correction_n]</b> to two instances, <b>second_order_correction_N[second_order_correction_x]</b> and <b>second_order_correction_N[second_order_correction_y]</b>.
    </p>
    <div class="scrollable">
    ```json
    "piezo_sensor": {
        "piezo_configuration": {
            "second_order_correction_N[second_order_correction_n]": [
            {
                "x": {
                "raw_path": "/Piezo Configuration/2nd order corr X/value",
                "@units": "/Piezo Configuration/2nd order corr X/unit"
                }
            },
            {
                "y": {
                "raw_path": "/Piezo Configuration/2nd order corr Y/value",
                "@units": "/Piezo Configuration/2nd order corr Y/unit"
                }
            }
            ],
        }
    }
    ```
    </div>
    <p> Or, simply write multiple fields like they are independent of each other.</p>
    <div class="scrollable">
    ```json
    "piezo_sensor": {
        "piezo_configuration": {
            "second_order_correction_N[second_order_correction_x]": {
                "raw_path": "/Piezo Configuration/2nd order corr X/value",
                "@units": "/Piezo Configuration/2nd order corr X/unit"
            },
            "second_order_correction_N[second_order_correction_y]": {
                "raw_path": "/Piezo Configuration/2nd order corr Y/value",
                "@units": "/Piezo Configuration/2nd order corr Y/unit"
            }
        }
    }
    ```
    </div>
=== "Variable name for NeXus `attribute`"
    <p>Similar to the field, a variadic attribute can have multiple instances. For sake of the explanation, let consider, <b>configurationNAME[configuration_name]</b> 
    is a variadic attribute of the <b>piezo_configuration</b> group. This situation can be written in config file, attribute <b>configurationNAME[configuration_name]</b> will be modified with multiple instances as <b>configurationNAME[configuration_name_x]</b> and <b>configurationNAME[configuration_name_y]</b>.</p>
    <div class="scrollable">
    ```json
    "piezo_sensor": {
        "piezo_configuration": {
            "@configurationNAME[configuration_name]": [
            {
                "name_x": {
                "raw_path": "default:@default:x_configuration"
                },
            },
            {
                "name_y": {
                "raw_path": "default:@default:y_configuration"
                }
            }
            ]
        },    
    }
    ```
    </div>
    <p> Or, simply write multiple attributes like they are independent of each other.</p>
    <div class="scrollable">
        ```json
        "piezo_sensor": {
            "piezo_configuration": {
                "@configurationNAME[configuration_name_x]": {
                    "raw_path": "default:@default:x_configuration"
                },
                "@configurationNAME[configuration_name_y]": {
                    "raw_path": "default:@default:y_configuration"
                }
            },    
        }
        ```
    </div>
__4.__ Write customized `NXdata` groups via the config file. It is often necessary for a user to annotate plots by defining the axis name and plot title.

=== "Customised `NXdata group`"
    <p>The <b>NXdata</b> can represent multiple instances of plotable data. Each set is defined by an object in the array of <b>DATA[data]</b>.
    Each object contains  <b>data</b> key refering the <b>DATA</b> field of <b>NXdata</b> base class, string of numbers (e.g., <b>"0"</b>, <b>"1"</b>) refering the index of the independent axis variable(s) for the <b>data</b>, <b>title</b> key for <b>title</b> field of <b>NXdata</b> group, and <b>grp_name</b> key defining the instance name of the <b>NXdata</b> group.
    <div class="scrollable">
    ```json
    "DATA[data]": [
        {
            "data": {
            "name": "Current",
            "raw_path": "/dat_mat_components/Current/value",
            "@units": "/dat_mat_components/Current/unit"
            },
            "0": {
            "name": "Bias Voltage",
            "raw_path": [
                "/dat_mat_components/Bias calc/value",
                "/dat_mat_components/Bias/value"
            ],
            "@units": [
                "/dat_mat_components/Bias calc/unit",
                "/dat_mat_components/Bias/unit"
            ]
            },
            "title": { "raw_path": "@default:Bias Spectroscopy" },
            "grp_name": "current"
        },
        {
            "data": {
            "name": "Current_filter",
            "raw_path": "/dat_mat_components/Current [filt]/value",
            "@units": "/dat_mat_components/Current [filt]/unit"
            },
            "0": {
            "name": "Bias Voltage",
            "raw_path": [
                "/dat_mat_components/Bias [filt]/value",
                "/dat_mat_components/Bias calc/value",
                "/dat_mat_components/Bias/value"
            ],
            "@units": [
                "/dat_mat_components/Bias calc/unit",
                "/dat_mat_components/Bias/unit"
            ]
            },
            "title": { "raw_path": "@default:Bias Spectroscopy(filter)" },
            "grp_name": "Current_filter"
        }
    ]
    ```
    </div>

__5.__ The `nxformatter` of `pynxtools-spm` has common functions, methods, and other programmatic tools that use the common rules in the config file as described above. The curated concepts should be written in the `template` object of `pynxtools`. However, there may be special cases where the generalized functions and methods do not work. In such cases, customized methods handle the special fields. To annotate which concepts or fields need special treatment, the config file has a key `#note`. The value of `#note` holds a human-readable description, e.g., the name of the method that handles the special case. The class variable `_grp_to_func` must have a map from the group name to the method name.

=== "Special case annotation via `#note` key"
    <p>This group <b>BIAS_SWEEP[bias_sweep]</b> is considered as a group that should be handled in a special method called <b>_construct_bias_sweep_grp</b>. To annotate this special case and information, the key <b>#note</b> is used.</p>
    <div class="scrollable">
    ```json
    "BIAS_SWEEP[bias_sweep]": {
        "#note": "This group will be handled in _construct_bias_sweep_grp.",
        "scan_type": "",
        "settling_time": {
            "raw_path": "/Bias Spectroscopy/Settling time/value",
            "@units": "/Bias Spectroscopy/Settling time/unit"
            },
    }
    ```
    </div>
    <p>And the class variable `_grp_to_func` look like this:</p>
    <div class="scrollable">
    ```python
    class NanonisDatSTS(NanonisBase):
        """Formatter for Nanonis STS data with .dat extension"""

        _grp_to_func = {
            "BIAS_SWEEP[bias_sweep]": "_construct_bias_sweep_grp", # Group name must start with "BIAS_SWEEP[bias_sweep]"
        }
    ```
    or
    ```python
    class NanonisDatSTS(NanonisBase):
        """Formatter for Nanonis STS data with .dat extension"""

        _grp_to_func = {
            "BIAS_SWEEP": "_construct_bias_sweep_grp", # Group name must start with "BIAS_SWEEP"
        }
    ```
    </div>

### __Default Features of `pynxtools-spm`__

There are some default features to handle raw data from specific vendor files.

__1.__ In STM, for Omicron raw files, the `SPM_SCAN_CONTROL[spm_scan_control_*]` group is instantiated for individual scans, e.g., `current_forward`, `current_backward`, `topography_forward`, `topography_backward`, etc.

=== "Multiple instances of `SPM_SCAN_CONTROL`"
    <p>In the concvention <b>SPM_SCAN_CONTROL[spm_scan_control_*]</b> the replacing part is <b>*</b>. For each scan the instance name shall be <b>SPM_SCAN_CONTROL[spm_scan_control_current_forward]</b>. As the name <b>SPM_SCAN_CONTROL</b> is fully replaceable, one can wish to define the instance name as wish, e.g, in the config file, <b>SPM_SCAN_CONTROL[*]</b> or <b>SPM_SCAN_CONTROL[any_prefix_*_any_suffix]</b> both are allowed but one sterisk wildcard <b>*</b> must be provided.</p>.
    <div class="scrollable">
    ```json
    "SCAN_ENVIRONMENT[scan_environment]": {
        "SPM_SCAN_CONTROL[spm_scan_control_*]": {
          "#note": "Handled in function _construct_nxscan_controllers. With '*' it is possible to add scan names, e.g., current_backward.",
          "scanTAG[scan_name]": {
            "raw_path": ""
          },
          "meshSCAN[mesh_scan]": {
            "backward_speedN[backward_speed_n]": {
              "raw_path": "",
              "@units": ""
            },
          },
        },
    }
    ```
    </div>

## __Some Useful Tips__

Using the code outside the reader is sometimes necessary for developers or users, especially when encountering errors or unexpected behavior.

__1.__ The parsers in `pynxtools-spm` parse a raw data file and organize the data in a slash-separated dictionary. The slash-separated keys represent the hierarchical structure followed in the raw file. To investigate how the raw data is organized, you can use the following code snippets.

=== "Parse a Nanonis file from STS experiment"
    <div class="scrollable">
    ```python
    from pynxtools_spm.parsers.nanonis_dat import NanonisDatSTS

    raw_file = "path/to/your/file.dat"

    parser: Dict[str, Any] = NanonisDatSTS(raw_file).parse()
    ```
    </div>
=== "Parse a Nanonis file from STM experiment"
    <div class="scrollable">
    ```python
    from pynxtools_spm.parsers.nanonis_sxm import SxmGenericNanonis

    raw_file = "path/to/your/file.dat"

    parser: Dict[str, Any] = SxmGenericNanonis(raw_file).parse()
    ```
    </div>
=== "Parse an Omicron file from STM experiment"
    <div class="scrollable">
    ```python
    from pynxtools_spm.parsers.omicron_sm4 import Sm4Omicron

    raw_file = "path/to/your/file.sxm"

    parser: Dict[str, Any] = Sm4Omicron(raw_file).parse()
    ```
    </div>

__2.__ The aim of the `nxformatter` of `pynxtools-spm` is to curate the raw data and ELN data. Later, the curated data is stored in a `template` object of `pynxtools`. To investigate how the data is curated, you can use the following code snippets.

=== "Curate a Nanonis file from STS experiment"
    <div class="scrollable">
    ```python

    from pynxtools.dataconverter import helpers
    from pynxtools.dataconverter.template import Template

    from pynxtools_spm.formatters.nanonis.nanonis_dat_sts import NanonisDatSTS

    nxdl_name = "NXsts"
    if nxdl_root is None:
        nxdl_root, _ = helpers.get_nxdl_root_and_path(nxdl=nxdl_name)

    template = Template()
    helpers.generate_template_from_nxdl(nxdl_root, template)

    raw_file = "path/to/your/file.dat"
    eln_file = "path/to/your/file.yaml"
    config_file = "path/to/your/config.json"

    formatter = NanonisDatSTS(template=template, raw_file=raw_file, 
                              eln_file=eln_file, config_file=config_file)
    
    curated_template: Template = formatter.get_nxformatted_template()

    ```
    </div>
=== "Curate a Nanonis file from STM experiment"
    <div class="scrollable">
    ```python

    from pynxtools.dataconverter import helpers
    from pynxtools.dataconverter.template import Template

    from pynxtools_spm.formatters.nanonis.nanonis_sxm_stm import NanonisSxmSTM

    nxdl_name = "NXstm"
    if nxdl_root is None:
        nxdl_root, _ = helpers.get_nxdl_root_and_path(nxdl=nxdl_name)

    template = Template()
    helpers.generate_template_from_nxdl(nxdl_root, template)

    raw_file = "path/to/your/file.sxm"
    eln_file = "path/to/your/file.yaml"
    config_file = "path/to/your/config.json"

    formatter = NanonisSxmSTM(template=template, raw_file=raw_file, 
                              eln_file=eln_file, config_file=config_file)
    
    curated_template: Template = formatter.get_nxformatted_template()

    ```
    </div>
=== "Curate an Omicron file from STM experiment"
    <div class="scrollable">
    ```python

    from pynxtools.dataconverter import helpers
    from pynxtools.dataconverter.template import Template

    from pynxtools_spm.formatters.omicron.omicron_sm4_stm import OmicronSm4STM

    nxdl_name = "NXstm"
    if nxdl_root is None:
        nxdl_root, _ = helpers.get_nxdl_root_and_path(nxdl=nxdl_name)

    template = Template()
    helpers.generate_template_from_nxdl(nxdl_root, template)

    raw_file = "path/to/your/file.sxm"
    eln_file = "path/to/your/file.yaml"
    config_file = "path/to/your/config.json"

    formatter = OmicronSm4STM(template=template, raw_file=raw_file, 
                              eln_file=eln_file, config_file=config_file)
    
    curated_template: Template = formatter.get_nxformatted_template()

    ```
    </div>
=== "Curate a Nanonis file from AFM experiment"
    <div class="scrollable">
    ```python

    from pynxtools.dataconverter import helpers
    from pynxtools.dataconverter.template import Template

    from pynxtools_spm.formatters.nanonis.nanonis_sxm_afm import NanonisSxmAFM

    nxdl_name = "NXafm"
    if nxdl_root is None:
        nxdl_root, _ = helpers.get_nxdl_root_and_path(nxdl=nxdl_name)

    template = Template()
    helpers.generate_template_from_nxdl(nxdl_root, template)

    raw_file = "path/to/your/file.dat"
    eln_file = "path/to/your/file.yaml"
    config_file = "path/to/your/config.json"

    formatter = NanonisSxmAFM(template=template, raw_file=raw_file, 
                              eln_file=eln_file, config_file=config_file)
    
    curated_template: Template = formatter.get_nxformatted_template()
    ```
    </div>
